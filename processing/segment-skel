#!/usr/bin/env python3
import networkx as nx
import numpy as np
import sys
import os
import operator
import open3d
import active_contours
from optparse import OptionParser

progname = os.path.basename(sys.argv[0])
usage_str = "Usage: %s [options] <points.txt> <edges.txt> <voxels.pcd>"%progname

parser = OptionParser(usage=usage_str)
parser.add_option("-w", "--width", dest="width",
                  help="voxel width", type="float", default=1.0)
parser.add_option("-d", "--dist", dest="dist",
                  help="distance of surface to voxel set", type="float", default=1.0)

(options, args) = parser.parse_args()
if len(args) < 3:
    print(parser.usage)
    parser.exit(1)

print("Segmenting graph object.")
# Create graph object from skeleton
pts = np.loadtxt(args[0])
edges = np.loadtxt(args[1], dtype=int)

def get_main_stem_and_internodes(G, root_node):
    # Get main stem as shortest path to point furthest from root
    predecessors, distances_to_root = nx.dijkstra_predecessor_and_distance(G, root_node)
    i = max(distances_to_root.items(), key=operator.itemgetter(1))[0]
    main_stem = [i]
    current_node = i
    while current_node != root_node:
        current_node = predecessors[current_node][0]
        main_stem.append(current_node)
    main_stem = np.array(main_stem, dtype=int)

    # Get internodes, sorted from closest to furthest to the root
    n_neighbors = np.array([len(list(nx.neighbors(G, g))) for g in main_stem], dtype=int)
    internodes = main_stem[n_neighbors > 2]
    internodes = internodes[::-1]
    return main_stem[::-1], internodes

def compute_mst(G, main_stem, internodes):
    # Set weights proportional to distance to internode
    # (for computing minimum spanning tree)
    G = G.copy()
    distances = {}
    for i in internodes:
        _, distances[i] = nx.dijkstra_predecessor_and_distance(G, i)

    distance_to_internode = {}
    for n in G.nodes():
        distance_to_internode[n] = min(distances[i][n] for i in internodes)

    def node_penalty(u, v):
        if u in main_stem or v in main_stem:
            return 0
        if len(list(nx.neighbors(G, u))) > 2 or len(list(nx.neighbors(G,v))) > 2:
            print(">2", u, v)
            return 10000 + distance_to_internode[u] + distance_to_internode[v]
        return (distance_to_internode[u] + distance_to_internode[v])

    for u,v in G.edges():
        G[u][v]['weight'] = node_penalty(u, v)


    # Compute minimum spanning tree
    T = nx.minimum_spanning_tree(G)
    return T

G = nx.Graph()
G.add_nodes_from(range(0, pts.shape[0]))

for i in range(edges.shape[0]):
    G.add_edge(edges[i, 0], edges[i, 1],
                weight=np.linalg.norm(pts[edges[i,0], :] - pts[edges[i,1], :]))


root_node = np.argmin(pts[:, 2])
main_stem, internodes = get_main_stem_and_internodes(G, root_node)
T = compute_mst(G, main_stem, internodes)

fruits = []
for i in internodes:
    ns = nx.neighbors(T, i)
    for n in ns:
        if n not in main_stem:
            temp_tree = T.copy()
            temp_tree.remove_edge(n, i)
            fruit, _ = get_main_stem_and_internodes(temp_tree, n)
            fruits.append(fruit)

print("Done! Adjusting point locations...")

voxels = open3d.read_point_cloud(args[2])
data = np.asarray(voxels.points)
for i in range(3):
    data[:,i] = data[:,i] - np.min(data[:, i])
indices = np.array(np.round(data[:, 0:3] / options.width), dtype=np.int)
shape = indices.max(axis=0)

ac = active_contours.TubularActiveContours(4)
ac.load_data(data, options.width)
def adjust_segment(nodes, num_per_step=1000, tol=1e-3, coef=1e-4, max_steps=10):
    y = np.zeros((len(nodes), 4))
    y[:,0] = 2*options.width
    y[:, 1:4] = pts[nodes, :]
    k = 0
    steps = 0
    prev_value = ac.V(y)
    while True:
        y = ac.step(y, coef)
        k += 1
        if k == num_per_step:
            new_value = ac.V(y)
            print(prev_value - new_value)
            steps += 1
            if prev_value - new_value < tol or steps >= max_steps:
                break
            prev_value = new_value
            k = 0
    return y[:, 1:4]

pts_stem = adjust_segment(main_stem)
pts[main_stem, :] = pts_stem

print("Done! Plotting...")

geometries = []
pcd = open3d.PointCloud()
pcd.points = open3d.Vector3dVector(pts[main_stem, :])
pcd.paint_uniform_color(np.random.rand(3))
geometries.append(pcd)

lines = open3d.LineSet()
lines.points = open3d.Vector3dVector(pts)
lines.lines = open3d.Vector2iVector(edges)

geometries.append(lines)

for f in fruits:
    adjusted_fruit = adjust_segment(f)
    pts[f, :] = adjusted_fruit
    pcd = open3d.PointCloud()
    pcd.points = open3d.Vector3dVector(pts[f, :])
    pcd.paint_uniform_color(np.random.rand(3))
    geometries.append(pcd)
open3d.draw_geometries(geometries)
